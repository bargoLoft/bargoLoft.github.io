[
  
  {
    "title": "알고리즘 스터디 복습 1주차(수학)",
    "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%8A%A4%ED%84%B0%EB%94%94-%EB%B3%B5%EC%8A%B5-1%EC%A3%BC%EC%B0%A8(%EC%88%98%ED%95%99)/",
    "categories": "코딩테스트",
    "tags": "수학",
    "date": "2024-07-06 21:57:00 +0900",
    





    
    "snippet": "번호 : 2609문제 : 최대공약수와 최대공배수난이도 : B1import java.util.Scanner;public class Main {    public static int GCD(int a, int b){        if(b==0) return a;        else return GCD(b, a%b)    }    public static...",
    "content": "번호 : 2609문제 : 최대공약수와 최대공배수난이도 : B1import java.util.Scanner;public class Main {    public static int GCD(int a, int b){        if(b==0) return a;        else return GCD(b, a%b)    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n1 = sc.nextInt();        int n2 = sc.nextInt();        int gcd = GCD(n1,n2);        int lcm = n1*n2/gcd;        System.out.println(gcd);        System.out.println(lcm);    }}// GCD 재귀함수 -&gt; 유클리드 호제법// 최소공배수 = 두 수의 곱 * 최대공약수번호 : 11653문제 : 소인수분해난이도 : B1import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int N = sc.nextInt();                for(int i=2;i&lt;=N;i++) {        \tif(N%i==0) {        \t\tSystem.out.println(i);        \t\tN/=i;        \t\ti=1;        \t}        }      }}17916KB 256ms// GPT 코드import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int N = sc.nextInt();                if (N &gt; 1) {            // 2부터 sqrt(N)까지의 수로 나누기            for (int i = 2; i * i &lt;= N; i++) {                while (N % i == 0) {                    System.out.println(i);                    N /= i;                }            }            // 마지막으로 남은 소수 출력            if (N &gt; 1) {                System.out.println(N);            }        }    }}// i * i &lt;= N 으로 루트N 까지만 탐색// if 대신 while(N % i == 0) 으로 한 번에17752KB\t212ms번호 : 13909문제 : 창문 닫기난이도 : S5import java.util.*;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\t\t\tdouble N = sc.nextDouble();\t\t\t\t// N번째 창문의 약수의 개수가 홀수면 1(열림), 짝수면 0(닫힘)\t\t// 약수의 개수가 홀수인 수는 제곱수들.\t\t// 따라서 &lt;=N 인 제곱수들을 구하면 된다.\t\tSystem.out.println((int)Math.floor(Math.sqrt(N)));\t}}// ceil 올림// floor 내림/* GPT 코드 */import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);                long N = sc.nextLong();                // N 이하의 완전제곱수의 개수를 구한다        System.out.println((int)Math.sqrt(N));    }}// long 타입으로 입력범위인 2,100,000,000 커버.// 이러면 floor가 필요없다.번호 : 1929문제 : 소수구하기난이도 : S3import java.util.Scanner;import java.util.List;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\t\t\tint M = sc.nextInt();\t\tint N = sc.nextInt();\t\t\t\tBoolean[] primeList = new Boolean[N+1];\t\t\t\t//배열 0,1 제외 전부 true로 초기화.\t\tfor(int i=2;i&lt;=N;i++) {\t\t\tprimeList[i] = true;\t\t}\t\t\t    primeList[1] = false; // 1은 소수가 아닙니다.\t\t\t    //에라토스테네스의 체 \t\t//소수인지 확인하려면 루트(N) 까지만 나눠보면 됨.\t\tfor(int p=2;p&lt;=Math.sqrt(N);p++) {\t\t\t// 그 수가 이미 지워졌다면 바로 continue\t\t\tif(primeList[p]==false)\t\t\t\tcontinue;\t\t\t\t\t\t// 자기 자신을 제외한 배수들 전부 지움.\t\t\tfor(int n=p*2;n&lt;=N;n+=p){\t\t\t\tif(primeList[n])\t\t\t\t\tprimeList[n] = false;\t\t\t}\t\t}\t\t\t\tfor(int i=M;i&lt;=N;i++) {\t\t\tif(primeList[i]==true)\t\t\t\tSystem.out.println(i);\t\t}\t}}37388\t972/* GPT 코드 */import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int M = sc.nextInt();        int N = sc.nextInt();        boolean[] isPrime = new boolean[N + 1];        // 배열 초기화: 처음에는 모든 수를 소수로 가정 (true)        for (int i = 2; i &lt;= N; i++) {            isPrime[i] = true;        }        // 에라토스테네스의 체 알고리즘        for (int p = 2; p * p &lt;= N; p++) {            if (isPrime[p]) {                // p의 배수들을 false로 설정                for (int multiple = p * p; multiple &lt;= N; multiple += p) {                    isPrime[multiple] = false;                }            }        }        // M 이상 N 이하의 소수를 출력        for (int i = M; i &lt;= N; i++) {            if (isPrime[i]) {                System.out.println(i);            }        }    }}// Boolean 대신 boolean으로 메모리 최적화// Math.sprt(N) 대신 p * p &lt;= N 이 더 효율적.// multiple이 p * p 시간인 이유는 p * (p-1) 까지는 이전 과정에서 지워지기 때문34220\t712번호 : 15649문제 : N과 M(1)난이도 : S3//BufferedReader, BufferedWriter,IOException,InputStreamReader,OutputStreamWriter 전부 java.io import java.io.*;import java.util.StringTokenizer;// N과 Mpublic class Main {\tstatic int N;\tstatic int M;\tstatic int[] arr;\tstatic int[] isUsed;\tpublic static StringBuilder sb = new StringBuilder();\t\t//순열 -&gt; 백트래킹 -&gt; 재귀 \tstatic void nPm(int dep) {\t\t// M개 채웠으면 출력하고 종료 \t\tif(dep == M) {\t\t\tfor(int n : arr) {\t\t\t\tsb.append(n+1).append(' ');\t\t\t}\t\t\tsb.append('\\n');\t\t\treturn;\t\t}\t\t\t\t//작은 수부터 확인해서 안 썼으면 채우고 다음 칸으로.\t\t//다음 재귀 호출 후에는 for문 i++으로 넘어가기 전 안 쓴 상태로 돌려놓음.\t\tfor(int i=0;i&lt;N;i++) {\t\t\tif(isUsed[i]==0) {\t\t\t\tarr[dep] = i;\t\t\t\tisUsed[i] = 1;\t\t\t\tnPm(dep+1);\t\t\t\tisUsed[i] = 0;\t\t\t}\t\t}\t}\t\t\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tString s = bufferedReader.readLine();\t\t\t\tStringTokenizer st = new StringTokenizer(s); //StringTokenizer 인자값에 입력 문자열 넣음\t\tN = Integer.parseInt(st.nextToken()); //첫번째 호출\t\tM = Integer.parseInt(st.nextToken()); //두번째 호출\t\t\t\tarr = new int[M];\t\tisUsed = new int[N];\t\t\t\tnPm(0);\t\t\t\tSystem.out.println(sb);\t}}//백트래킹 //백트래킹의 시작. 기본 구조을 익혀놓으면 다른 문제에도 적용가능.//ex) 9663 N-Queen, 1182 부분수열의 합  //참조 -&gt; 바킹독 블로그 - 백트래킹.//https://blog.encrypted.gg/945 //전역변수 c처럼 static 으로 클래스 영역에 선언.//백준 8%에서 시간초과.//java - println() 1000만 까지 자연수 찍는 속도 평균 30초.//java - BufferedWriter 0.9초//java - StringBuilder를 이용해 문자열 하나로 합친 뒤 println() 1.2초 //참조 -&gt; 백준 출력속도 비교 https://www.acmicpc.net/blog/view/57/* GPT CODE */import java.io.*;import java.util.StringTokenizer;public class Main {    static int N;    static int M;    static int[] arr;    static boolean[] isUsed;    public static StringBuilder sb = new StringBuilder();    static void nPm(int depth) {        // M개 채웠으면 출력하고 종료         if (depth == M) {            for (int i = 0; i &lt; M; i++) {                sb.append(arr[i]).append(' ');            }            sb.append('\\n');            return;        }        // 작은 수부터 확인해서 안 썼으면 채우고 다음 칸으로.        // 다음 재귀 호출 후에는 for문 i++으로 넘어가기 전 안 쓴 상태로 돌려놓음.        for (int i = 1; i &lt;= N; i++) {            if (!isUsed[i]) {                arr[depth] = i;                isUsed[i] = true;                nPm(depth + 1);                isUsed[i] = false;            }        }    }    public static void main(String[] args) throws IOException {        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));                StringTokenizer st = new StringTokenizer(bufferedReader.readLine());        N = Integer.parseInt(st.nextToken());        M = Integer.parseInt(st.nextToken());                arr = new int[M];        isUsed = new boolean[N + 1];                nPm(0);                System.out.println(sb);    }}// arr 배열에 직접 선택된 숫자 저장.// isUsed 배열을 boolean 타입으로 선언. 메모리 절약.// 전형적인 백트레킹 문제// N과 M 시리즈 다 풀었지롱번호 : 10974문제 : 모든 순열난이도 : S3//BufferedReader, BufferedWriter,IOException,InputStreamReader,OutputStreamWriter 전부 java.io import java.io.*;import java.util.StringTokenizer;// 모든 순열 public class Main {\tstatic int N;\tstatic int M;\tstatic int[] arr;\tstatic int[] isUsed;\tpublic static StringBuilder sb = new StringBuilder();\t\t//순열 -&gt; 백트래킹 -&gt; 재귀 \tstatic void nPm(int dep) {\t\t// M개 채웠으면 출력하고 종료 \t\tif(dep == M) {\t\t\tfor(int n : arr) {\t\t\t\tsb.append(n+1).append(' ');\t\t\t}\t\t\tsb.append('\\n');\t\t\treturn;\t\t}\t\t\t\t//작은 수부터 확인해서 안 썼으면 채우고 다음 칸으로.\t\t//다음 재귀 호출 후에는 for문 i++으로 넘어가기 전 안 쓴 상태로 돌려놓음.\t\tfor(int i=0;i&lt;N;i++) {\t\t\tif(isUsed[i]==0) {\t\t\t\tarr[dep] = i;\t\t\t\tisUsed[i] = 1;\t\t\t\tnPm(dep+1);\t\t\t\tisUsed[i] = 0;\t\t\t}\t\t}\t}\t\t\tpublic static void main(String[] args) throws IOException {\t\tBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\t\t\t\tString s = bufferedReader.readLine();\t\t\t\tStringTokenizer st = new StringTokenizer(s); //StringTokenizer 인자값에 입력 문자열 넣음\t\tN = Integer.parseInt(st.nextToken()); //첫번째 호출\t\tM = N;\t\t\t\tarr = new int[M];\t\tisUsed = new int[N];\t\t\t\tnPm(0);\t\t\t\t//StringBuilder로 한 번에 출력.\t\tSystem.out.println(sb);\t}}/* GPT CODE */import java.io.*;public class Main {    static int N;    static int[] arr;    static boolean[] isUsed;    public static StringBuilder sb = new StringBuilder();    // 순열 생성 (백트래킹)    static void generatePermutations(int depth) {        if (depth == N) {            for (int i = 0; i &lt; N; i++) {                sb.append(arr[i]).append(' ');            }            sb.append('\\n');            return;        }        for (int i = 1; i &lt;= N; i++) {            if (!isUsed[i]) {                arr[depth] = i;                isUsed[i] = true;                generatePermutations(depth + 1);                isUsed[i] = false;            }        }    }    public static void main(String[] args) throws IOException {        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));                N = Integer.parseInt(bufferedReader.readLine());                arr = new int[N];        isUsed = new boolean[N + 1];                generatePermutations(0);                System.out.print(sb);    }}// M은 왜 따로 했던 걸까..?// i = 1 ; i &lt;= N 로 하면 arr[depth], isUsed[i] 두 인덱스가 일치 하지 않는데..// 이 부분은 편의성을 위해 내 방식대로 하는 게 나을듯. 헷갈리잖아.번호 : 4948문제 : 베르트랑 공준난이도 : S2import java.util.Scanner;public class Main {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\t\t\t\t\twhile(true) {\t\t\tint N = sc.nextInt();\t\t\t\t\t\tif(N == 0) break;\t\t\t\t\t\tBoolean[] primeList = new Boolean[2*N+1];\t\t\t\t\t\t//배열 0,1 제외 전부 true로 초기화.\t\t\tfor(int i=2;i&lt;=2*N;i++) {\t\t\t\tprimeList[i] = true;\t\t\t}\t\t\t\t\t    primeList[1] = false; // 1은 소수가 아닙니다.\t\t\t\t\t    //에라토스테네스의 체 \t\t\t//소수인지 확인하려면 루트(N) 까지만 나눠보면 됨.\t\t\tfor(int p=2;p&lt;=Math.sqrt(2*N);p++) {\t\t\t\t// 그 수가 이미 지워졌다면 바로 continue\t\t\t\tif(primeList[p]==false)\t\t\t\t\tcontinue;\t\t\t\t\t\t\t\t// 자기 자신을 제외한 배수들 전부 지움.\t\t\t\tfor(int n=p*2;n&lt;=2*N;n+=p){\t\t\t\t\tif(primeList[n])\t\t\t\t\t\tprimeList[n] = false;\t\t\t\t}\t\t\t}\t\t\t\t\t\tint cnt = 0;\t\t\t\t\t\tfor(int i=N+1;i&lt;=2*N;i++) {\t\t\t\tif(primeList[i]==true)\t\t\t\t\tcnt++;\t\t\t}\t\t\t\t\t\tSystem.out.println(cnt);\t\t}\t}}//배운 점.//배열 Boolean으로 선언 시 Object니까 초기화 해주어야 함.//안 하고 읽으면 바로 Null/* GPT CODE */import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        // 소수 여부를 저장하는 배열        int maxLimit = 123456 * 2;  // 문제의 제한 조건에 따라 최대 2 * 123456 까지 고려        boolean[] isPrime = new boolean[maxLimit + 1];                // 에라토스테네스의 체를 사용하여 소수 판별        for (int i = 2; i &lt;= maxLimit; i++) {            isPrime[i] = true;        }        for (int i = 2; i * i &lt;= maxLimit; i++) {            if (isPrime[i]) {                for (int j = i * i; j &lt;= maxLimit; j += i) {                    isPrime[j] = false;                }            }        }        while (true) {            int N = sc.nextInt();            if (N == 0) break;            int count = 0;            for (int i = N + 1; i &lt;= 2 * N; i++) {                if (isPrime[i]) {                    count++;                }            }            System.out.println(count);        }        sc.close();    }}// 왜 Boolean을 자꾸 썼을까? Collection도 아니고// 에라토스테네스의 체 적용복습 후기배열에 자꾸 참조 타입을 써서 메모리 소비만 늘린 점. 몰 랐 으 니 까.백트레킹 코드도 다시 짜라고 하면 못 할 것 같다. 프로그래머스에서 풀어보기.sqrt 대신 제곱으로 사용하는 것 같이 사소한 부분 신경 쓰기.소수 → 에라토스테너스의 체순열 → 백트레킹을 사용하라 이 말이다."
  },
  
  {
    "title": "코테 필수 문법 정리",
    "url": "/posts/%EC%BD%94%ED%85%8C-%ED%95%84%EC%88%98-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/",
    "categories": "코딩테스트",
    "tags": "",
    "date": "2024-07-01 23:56:00 +0900",
    





    
    "snippet": "Primitive / Reference 타입int, long, float, double … Primitive → 원시 타입Integer, Long, Float, Double … Reference → 참조 타입Primitive Type, 원시 타입  실제 값, value 을 직접 저장합니다.  스택 메모리에 저장됩니다. 크기가 작고 고정되어 있어 효율적...",
    "content": "Primitive / Reference 타입int, long, float, double … Primitive → 원시 타입Integer, Long, Float, Double … Reference → 참조 타입Primitive Type, 원시 타입  실제 값, value 을 직접 저장합니다.  스택 메모리에 저장됩니다. 크기가 작고 고정되어 있어 효율적으로 관리 됩니다.  기본 타입 종료          정수 타입 : byte, short, int, long      부동 소수점 타입 : float, double      문자 타입 : char      논리 타입 : boolean        기본값          초기화 되지 않은 Primitive 타입 변수는 기본 값을 가집니다                  int → 0 / boolean → false / char → ‘/u0000’ (NULL)                    성능엡실론을 포함한 연산에 주의하라자바는 부동소수형 데이터를 이진법으로 표현하기 때문에 오차가 발생. → 엡실론, epsilon# 04-2 컬렉션 프레임워크컬렉션 프레임워크는 여러 값을 효율적으로 처리하는 표준화 클래스 집합으로, 주로 리스트, 큐, 스택, 해시맵 등을 포함합니다.## 배열배열은 저장할 데이터 개수가 정해져 있을 때 유용하며, `Arrays.toString()` 메서드로 출력할 수 있습니다.```javaimport java.util.Arrays;public class Solution {    public static void main(String[] args) {        int[] array = { 1, 2, 3, 4, 5 };        System.out.println(Arrays.toString(array)); // [1, 2, 3, 4, 5]    }}배열은 크기 변경이 불가능하며, 인덱스를 사용해 특정 원소에 빠르게 접근할 수 있습니다.import java.util.Arrays;public class Main {    public static void main(String[] args) {        int[] myArray = { 1, 4, 2, 5, 3 };        myArray[1] = 7;        System.out.println(Arrays.toString(myArray)); // [1, 7, 2, 5, 3]        System.out.println(myArray[2]); // 2        myArray[4] = myArray[2];        System.out.println(Arrays.toString(myArray)); // [1, 7, 2, 5, 2]    }}리스트ArrayList는 가변 크기의 리스트로, 새 데이터를 추가할 때는 O(1), 중간에 삽입할 때는 O(N)입니다.import java.util.ArrayList;public class ListExample {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(2);        list.add(4);        System.out.println(list.get(2)); // 4        System.out.println(list); // [1, 2, 4]    }}해시맵HashMap은 키-값 쌍을 저장하는 해시 테이블입니다.import java.util.HashMap;public class HashMapExample {    public static void main(String[] args) {        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();        map.put(\"apple\", 1);        map.put(\"banana\", 2);        System.out.println(map); // {banana=2, apple=1}        if (map.containsKey(\"apple\")) {            System.out.println(\"apple: \" + map.get(\"apple\")); // apple: 1        }                map.put(\"banana\", 4);        System.out.println(map); // {banana=4, apple=1}        map.remove(\"banana\");        System.out.println(map); // {apple=1}    }}문자열문자열은 이뮤터블 객체입니다. StringBuilder는 문자열을 효율적으로 다루기 위해 사용됩니다.public class StringBuilderExample {    public static void main(String[] args) {        StringBuilder sb = new StringBuilder();        sb.append(\"Hello\");        sb.append(\" World\");        System.out.println(sb.toString()); // Hello World    }}"
  },
  
  {
    "title": "시간복잡도",
    "url": "/posts/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/",
    "categories": "코딩테스트",
    "tags": "",
    "date": "2024-06-19 00:00:00 +0900",
    





    
    "snippet": "시간복잡도, time complexity알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미알고리즘 수행 시간을 측정하는 방법      절대 시간    말 그대로 시간을 측정.    그러나 실행 환경에 따라 달라질 수 있기에 실제로 활용 X        시간 복잡도    알고리즘이 시작한 순간부터 결괏값이 나올 때까지의 연산 ...",
    "content": "시간복잡도, time complexity알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미알고리즘 수행 시간을 측정하는 방법      절대 시간    말 그대로 시간을 측정.    그러나 실행 환경에 따라 달라질 수 있기에 실제로 활용 X        시간 복잡도    알고리즘이 시작한 순간부터 결괏값이 나올 때까지의 연산 횟수    최선, 평균, 최악의 경우로 나눔 (Best, Normal, Worst)    코테는 모든 경우의 수에서 테케를 성공해야하기에 최악의 경우를 가정  Big-O 표기법점근적 표기법, 어떤 함수의 증가하는 추세를 표현하는 표기법.ex) 2x^2 + 3x + 5 ⇒ O(x^2)우선순위는 지수함수 &gt; 다항함수 &gt; 로그함수시간복잡도 → 코테?일반적으로 1초의 1억 번의 연산을 가정.출제자의 의도라면 넉넉잡아 1,000만 ~ 3,000만을 고려해 시간 복잡도 생각하면 됨.외우면 편한 것sort() → O(nlogn)이진탐색 → O(logn)Heap(priority queue) : push(), pop() → O(logn)Java 실행시간 측정 코드long beforeTime = System.currentTimeMillis(); // 코드 실행 전 시간        // 코드        long afterTime = System.currentTimeMillis(); // 코드 실행 후 시간 long secDiffTime = (afterTime - beforeTime)/1000; // 두 시간 차 계산System.out.println(\"실행 시간(m): \"+secDiffTime);자료구조에 따른 시간 복잡도      배열의 접근성    인덱스만 알고 있다면 빠른 조회 가능. 그러나 검색, 삽입, 삭제는…        스택, 큐, 연결리스트의 삽입 / 삭제    주소를 참조하고 있기에 빠른 삽입, 손절 가능. 그러나 조회, 검색은…        해시 테이블의 검색 / 삽입 / 삭제    평균적으로 O(1)로 검색, 삽입, 삭제 가능. 그러나 최악의 경우엔 O(n) 걸림(해시 충돌)        이진탐색 트리의 O(log(n)) 조회 / 검색 / 삽입 / 삭제    평균적으로 O(log(n)) 조회, 검색, 삽입, 삭제 가능. 단 균형 잡힌 트리여야 함.    중위 순회를 통해 O(n)으로 정렬된 데이터를 얻을 수 있음    최소값, 최대값, 전위, 후위, 중위 순회등 다양한 트리 연산 지원.    특정 범위의 값을 효율적으로 탐색 가능. 이는 해시 테이블에 비해 큰 이점.    최악의 경우(트리가 한 쪽으로 치우친) O(n)…. → AVL트리, 레드블랙 트리로 해결  각 정렬 알고리즘 별 시간복잡도"
  },
  
  {
    "title": "코테 기본기 복습",
    "url": "/posts/%EC%BD%94%ED%85%8C-%EA%B8%B0%EB%B3%B8%EA%B8%B0-%EB%B3%B5%EC%8A%B5/",
    "categories": "코딩테스트",
    "tags": "",
    "date": "2024-06-16 17:24:00 +0900",
    





    
    "snippet": "Java 입출력import java.io.*;import java.util.*;public class StandardIO {    public static void main(String[] args) throws IOException {            // BufferedReader 선언\t\t    BufferedReader br = new Buf...",
    "content": "Java 입출력import java.io.*;import java.util.*;public class StandardIO {    public static void main(String[] args) throws IOException {            // BufferedReader 선언\t\t    BufferedReader br = new BufferedReader(new InputStringReader(System.in));\t\t    StirngTokenizer st = new StringTokenizer(br.readLine());\t\t    StringBuilder sb = new StringBuilder();\t\t    \t\t    // 한 줄 통째로 가져오기\t\t    String s = br.readLine();\t\t    int i = Integer.parseInt(br.readLine());\t\t    \t\t    // StringTokenizer로 공백 단위로 가져오기\t\t    st = new StringTokenizer(br.readLine());\t\t    int N = Integer.parseInt(st.nextToken());\t\t    \t\t    // StringBuilder에 넣기\t\t    sb.append(s);\t\t    \t\t    // 출력\t\t    System.out.println(sb);\t\t    System.out.printf(%s, sb.toString());\t\t    System.out.print(sb);\t\t        }}백준 풀 때는 IntelliJ IDE로 풀고기본 입출력 코드는 복붙하고 시작했다.그러다 보니 막상 실제 코테 환경에서 throws IOException을 빼먹어서아무것도 못하는 사태 발생.그런 의미에서 입출력 코드부터 손코딩하고 시작."
  },
  
  {
    "title": "깃허브 블로그 시작",
    "url": "/posts/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91/",
    "categories": "Github",
    "tags": "",
    "date": "2024-03-10 00:00:00 +0900",
    





    
    "snippet": "깃허브 블로그를 시작하는 이유네이버 블로그에 Flutter 관련 개발 작성-&gt; 일상글과 분리하리 위해 Velog 개설Velog의 중구난방의 글과 일정하지 못한 카테고리, 카테고리 설정-&gt; 카테코리, 태그 정리와 커스텀 설정을 위해 깃허브 블로그 이주앞으로의 계획  현재 진행중인 생선가게 백엔드 진행 과정 기록  삼성 B형 역량테스트 대비 알...",
    "content": "깃허브 블로그를 시작하는 이유네이버 블로그에 Flutter 관련 개발 작성-&gt; 일상글과 분리하리 위해 Velog 개설Velog의 중구난방의 글과 일정하지 못한 카테고리, 카테고리 설정-&gt; 카테코리, 태그 정리와 커스텀 설정을 위해 깃허브 블로그 이주앞으로의 계획  현재 진행중인 생선가게 백엔드 진행 과정 기록  삼성 B형 역량테스트 대비 알고리즘 풀이 기록  이전 프로젝트 및 토이 프로젝트 정리해서 기록"
  }
  
]

